# MCGA: Make Code GREAT Again

该文档基本实现了C++设计模式的所有案例，其中他们的分类如下：


## 1.组件协作模式

| **组件协作模式**  | **使用场景** |
|------------------|------------------|
| **模板方法**   | 定义了算法的骨架，并允许子类在不改变结构的前提下重写特定步骤，以实现不同的算法。适用于通用算法有固定步骤、但部分实现可以变动的场景。 |
| **策略模式**   | 定义了一系列算法，使它们可以互相替换，并将它们封装在一个类中。适用于需要在运行时选择不同算法以适应不同情况的场景。 |
| **观察者模式** | 定义了对象之间的一种一对多依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都会收到通知并自动更新。适用于对象之间需要保持一致性、或者一个事件触发多种行为的场景。 |



## 2. 单一职责模式
> 如果在软件组件的设计中，责任划分不清晰，通过继承的结果往往会根据需求的变化而变化，这样会导致子类急剧膨胀，同时充斥大量重复代码，这时需要划清责任！需要单一职责模式来进行协助。

| **单一职责模式**      | **使用场景** |
|----------------------|------------------|
| **装饰器模式**      | 允许向一个现有对象添加新功能，同时又不改变其结构。这种类型的设计模式作为结构型模式，通过创建一个装饰类包装原有的类，提供了一种扩展功能的方式，而不需要修改原始代码。适用于在运行时动态添加功能的场景。 |
| **桥模式**          | 将抽象部分与实现部分分离，使它们可以独立变化。通过组合的方式，桥接模式允许抽象层和实现层独立发展，有助于降低扩展复杂度。适用于一个系统有多角度分类，每一种分类都可能变化的场景。 |

## 3. 对象创建模式
> 通过“对象创建”来绕开new，避免紧耦合，从而支持对象创建的稳定，是接口抽象之后的第一步工作。

| **对象创建模式**  | **使用场景** |
|------------------|------------------|
| **工厂方法**   | 定义了算法的骨架，并允许子类在不改变结构的前提下重写特定步骤，以实现不同的算法。适用于通用算法有固定步骤、但部分实现可以变动的场景。 |
| **抽象工厂**   | 定义了一系列算法，使它们可以互相替换，并将它们封装在一个类中。适用于需要在运行时选择不同算法以适应不同情况的场景。 |
| **构建器** | 定义了对象之间的一种一对多依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都会收到通知并自动更新。适用于对象之间需要保持一致性、或者一个事件触发多种行为的场景。 |




---
## 2.使用方法：
将仓库拷贝至本地：
```bash
git clone git@github.com:doublesevenshop/Design.git
```

每一个目录都有对应的详解，以及未优化的代码和优化后的代码，使用g++进行编译：
```bash
g++ -o output_name_old old.cpp
g++ -p output_name_new new.cpp

./ output_name_old
./ output_name new
```