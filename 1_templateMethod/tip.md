### Template Method 设计模式的核心设计原则

**Template Method** 模式的核心在于定义一个操作中的算法的框架，允许子类在不改变算法结构的情况下，重定义算法的某些特定步骤。这种模式主要用来实现代码的复用及扩展的同时，还可以提供固定的算法架构。

### 核心设计原则

1. **封装不变部分，扩展可变部分**：
   Template Method 模式通过把不变的行为搬移到超类，去除子类中的重复代码来体现封装。可变的行为则保留在子类中实现，提供扩展的可能性。

2. **利用继承推迟决策**：
   通过继承，子类可以选择如何实现算法中的某些步骤，即在超类中定义非具体操作（通过虚函数实现），这样的设计让子类可以自主决定如何实现这些步骤。

3. **提供框架和挂钩（hooks）**：
   Template Method 不仅定义算法的框架，还可以提供挂钩来让子类“挂入”或改变算法的具体内容，而不改变算法的结构。

### 使用情景

Template Method 模式适用于以下情况：

1. **多个类有相似的行为，但具体实现细节有所不同**：
   当不同的实现有着部分相同的步骤时，可以使用 Template Method 模式来提取这些共通的步骤到一个公共父类中，通过抽象方法让子类实现具体的细节。

2. **代码复用**：
   当多个类的方法中包含重复的代码时，Template Method 模式是一种将共有代码移动到单一位置，防止代码冗余的策略。

3. **控制子类扩展**：
   你可以在模板方法中不仅定义抽象的操作，也定义具体的操作和顺序，它定义了一个算法的骨架。通过这种方式，可以准确控制子类的扩展。

4. **关键过程的固定算法**：
   在需要固定算法结构，同时允许算法具有一定的灵活性和适应性时，可以使用 Template Method 模式。例如，在游戏中，游戏的启动、进行和结束是固定的，但具体如何启动、进行和结束则可以由具体的游戏来决定。

### 示例中的应用

在代码示例中：

- **`Game` 类定义了游戏的基本流程**（`play` 方法），这是一个固定的算法骨架。
- **子类 `Chess`, `Poker` 分别实现这些步骤**，根据不同游戏的需要重定义 `start`, `playing`, 和 `end` 方法。
- **新功能的引入**（如在 `Chess` 中的 `newFeature` 方法和 `addNewGameFeature` 钩子）展示了模板方法的扩展性，允许在不改变主流程的情况下插入新的行为。
