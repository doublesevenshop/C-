# Strategy策略模式
动机：
在软件构建过程中，某些算法多种多样，如果都编码到对象中，会让对象非常复杂，那如何解决呢？

作为设计来说，需要动态修改代码时，直接在代码对象的实现中修改会非常复杂，同时也会使得重新编译更慢。我们更希望对扩展开放，对更改封闭。例如：
```c++
class A {
    double caculate() {
        if(some == 1) {

        } 
        else if(some == 2) {

        }
        else if(some == 3) {

        }
        ...

    }
};
```
当需求更多的时候，如果还是增加`else if`，就会让代码显得十分冗余。

那么如何来解决这个问题呢？
```c++
class A{
    virtual ~A(){}
    virtual double caculate() = 0;
};
class B : A {
    virtual double caculate() override {
        ...
    }
};
class C : A {
    virtual double caculate() override {
        ...
    }
}
```
这种增加方式我们可以在A的基础上不断扩增，通过扩展的方式，而不是直接修改代码的方式，会更加优雅高效。

那么我们怎么去使用呢？
```c++
class User{
    A* strategy; // 使用指针，但是智能指针更好
    double caculate() {
        double val = strategy->caculate(); // 这里就是一个多态调用
    }
};
```

这种修改属于增量修改，遵循开放封闭原则，面向对象的复用性更多的指的是二进制的复用，编译测试之后是原封不动，而不是部分代码的复制粘贴。

并且在一个方法后边添加代码的时候，前边的代码也会经常出现bug。

strategy及其子类为组建提供了一系列可重用的算法，使得类型在**运行时**方便地根据需要在各个算法之间切换

Strategy提供了条件判断语句之外的选择，消除了判断语句，就是在解耦合，许多使用到条件语句的代码通常都需要Strategy模式。

如果Strategy对象没有实例对象，那么各个上下文可以共享一个对象，节省性能开销。（使用单例模式）

一般来说，需要动态判断的地方，就是可以使用Strategy的地方。

有时候加载不适用的代码，也是一种负担，例如ifelse代码中，有很多部分被装载到内存中，但是只有一个分支会被选择，因此存在一定的浪费。

